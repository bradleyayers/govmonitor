# coding=utf-8
"""Deployment tasks.

To use this fabfile, you must first configure several ``env`` settings:
``env.host``, ``env.user``, etc. Constraints apply to these settings:

* ``env.user`` on the host must be the owner of the site's files and it must
  allow SSH connections (``authorized_keys`` or similar must be configured).
* ``env.user`` on the host must have permission to reload Apache and write to
  its ``sites-{available,enabled}`` directories (``sudo`` must be configured).

Several assumptions are made about both the host and repository layout:

* Apache's ``sites-{available,enabled}`` directories must be located in
  ``/etc/apache2``. This is the default if Apache was installed with aptitude.
* The site's configuration files in said directories must be named after the
  project (i.e. their filenames must be equal to ``env.project_name``).
* If it's being used, Solr's home directory must be ``/etc/opt/solr``, it must
  be running on port ``8983``, and the core administration interface must be
  accessible at ``http://localhost:8983/solr/admin/cores`` (no trailing slash).
"""
from fabric.api import *
from fabric.colors import green, red, yellow
from fabric.contrib.files import exists
from fabric.utils import indent
import os.path
import sys


# The host we are deploying to and the credentials that should be used for SSH
# and sudo prompts. Do not include a username in the host (e.g. user@host).
env.host = "HOST"
env.user = "USER"
env.password = "PASSWORD"

# The paths of files or directories that must be preserved across deployments,
# relative to the project directory. Silently fails if a file doesn't exist.
env.preserved_files = (
    "deployment/apache.conf",
    "deployment/apache.conf.maintenance",
)

# The project name: the name of the project's root python module. The project
# directory within the site's root directory must also share this name.
env.project_name = "PROJECT_NAME"

# The deployment's root directory on the server, containing the project's root
# directory, logs, etc. This is effectively our "working" area.
env.root_directory = "ROOT_DIRECTORY"

# The name of the site's Solr core or None if the host isn't running Solr.
env.solr_core_name = "SOLR_CORE_NAME"


@task
def deploy():
    """Deploy to the server.

    The branch that is deployed is that of the repository in the root
    directory. Thus, it must have the master branched checked out for a
    production deployment, development for a development deployment, etc.

    Maintenance mode is turned on while deploying. It if was on before
    deployment began, it will remain so when it has finished.

    .. note::

        This task does not perform database migrations.
    """
    _check_root_directory()
    _check_project_directory()

    # Is maintenance mode on? If not, turn it on.
    maintenance_was_on = exists(os.path.join(
            env.root_directory, "maintenance"))

    if not maintenance_was_on:
        print "> Turning maintenance mode on."
        maintenance("on")

    try:
        # Create a copy of the project directory as a backup.
        run("cp -R \"{0}\" \"{0}_old\"".format(env.project_directory))

        with cd(env.project_directory):
            # Pull down the latest version.
            print "> Pulling the latest version."
            run("git reset --hard HEAD && git pull origin")

            with prefix("source environment/bin/activate"):
                # Install requirements. We're working in the original
                # repository so we've got the requirements cache!
                print "> Installing requirements."
                run("pip install -r requirements.txt "
                    "--download-cache=requirements_cache")

                # Collect static files.
                print "> Collecting static files."
                run("\"{0}/manage.py\" collectstatic --noinput".format(
                        env.project_name))

            # Copy preserved files from the backup.
            print "> Copying preserved files."
            old_project_directory = env.project_directory + "_old"

            for path in env.preserved_files:
                try:
                    # Recursive so directories are copied.
                    run("cp -R \"{0}\" \"{1}\"".format(
                            os.path.join(old_project_directory, path),
                            os.path.join(env.project_directory, path)))
                except SystemExit:
                    print yellow("Couldn't preserve the file \"%s\"." % path)

        # Refresh the Solr core.
        if env.solr_core_name:
            print "> Refreshing Solr core."
            _refresh_solr_core()

        print "> Setting permissions."
        _set_permissions()

        # We're done! Remove the backup.
        run("rm -fr \"{0}_old\"".format(env.project_directory))
    except (Exception, SystemExit):
        # Something failed; restore the backup. Catching any old exception
        # isn't good practice, but we really don't want the site to go down.
        run("rm -fr \"{0}\"".format(env.project_directory))
        run("mv \"{0}_old\" \"{0}\"".format(env.project_directory))

    # This reloads Apache for us; how convenient. If maintenance mode is
    # staying on, we don't need to reload it anyway!
    if not maintenance_was_on:
        print "> Turning maintenance mode off."
        maintenance("off")

    print green("Done!")


@task
def maintenance(state=""):
    """Turn maintenance mode on or off.

    .. code-block:: bash

        $ fab maintenance:on
        Maintenance mode on.
        $ fab maintenance:off
        Maintenance mode off.
    """
    if state == "":
        print "Usage:\n", indent(["fab maintenance:on", "fab maintenance:off"])
        sys.exit()

    if state not in ("on", "off"):
        message = "Invalid argument \"{0}\": must be \"on\" or \"off\"."
        print red(message.format(state))
        sys.exit(1)

    _check_root_directory()
    _check_project_directory()

    # Does the required Apache configuration file exist?
    deployment_directory = os.path.join(env.project_directory, "deployment")
    apache_conf_file = os.path.join(deployment_directory, "apache.conf%s"
            % (".maintenance" if state == "on" else ""))

    if not exists(apache_conf_file):
        message = "The Apache configuration file \"%s\" doesn't exist."
        print red(message % apache_conf_file)
        sys.exit(1)

    # Does the maintenance directory exist? This is only required when turning
    # maintenance mode on as its contents are served in place of the site.
    maintenance_directory = os.path.join(deployment_directory, "maintenance")
    if state == "on" and not exists(maintenance_directory):
        message = "The maintenance directory \"%s\" doesn't exist."
        print red(message % maintenance_directory)
        sys.exit(1)

    # Remove the copied maintenance directory (if it exists).
    with settings(warn_only=True):
        run("rm -r \"%s\"" % os.path.join(env.root_directory, "maintenance"))

    # Copy the Apache configuration files (overrides old ones).
    for directory in ("available", "enabled"):
        sudo("cp \"{0}\" \"/etc/apache2/sites-{1}/{2}\"".format(
                apache_conf_file, directory, env.project_name))

    # Copy the maintenance files if we're turning maintenance mode on; that
    # way, deploying a new version won't override the files being served!
    if state == "on":
        run("cp -R \"{0}\" \"{1}\"".format(maintenance_directory,
                os.path.join(env.root_directory, "maintenance")))

    # Set permissions, reload Apache, and we're done!
    _set_permissions()
    sudo("/etc/init.d/apache2 reload")
    print green("Maintenance mode %s." % state)


def _check_project_directory():
    """Check that the project directory exists."""
    path = env.project_directory
    if not exists(path):
        print red("The project directory \"%s\" doesn't exist." % path)
        sys.exit(1)


def _check_root_directory():
    """Check that the root directory exists."""
    path = env.root_directory
    if not exists(path):
        print red("The root directory \"%s\" doesn't exist." % path)
        sys.exit(1)


def _refresh_solr_core():
    """Refreshes the site's Solr core.

    Copies the site's Solr configuration files into the core's ``conf``
    directory and reloads it using the core administration interface.

    .. note::

        Assumes that ``env.solr_core_name`` is not ``None``.

    .. warning::

        This method doesn't rebuild the index.
    """
    with cd(os.path.join(env.project_directory, "deployment")):
        # Ensure that the required configuration files exist.
        for filename in ("solr_config.xml", "solr_schema.xml"):
            if not exists(filename):
                message = "The Solr configuration file \"%s\" doesn't exist."
                print red(message % filename)
                sys.exit(1)

        # Copy the configuration files into Solr's home directory.
        core_directory = "/etc/opt/solr/%s/conf" % env.solr_core_name
        sudo("cp solr_config.xml \"%s/solrconfig.xml\"" % core_directory)
        sudo("cp solr_schema.xml \"%s/schema.xml\"" % core_directory)

    # Reload the core.
    run("curl localhost:8983/solr/admin/cores?action=RELOAD&core=%s"
        % env.solr_core_name)


def _set_permissions():
    """Set permissions throughout the site directory.

    ..note ::

        Assumes that both the root and project directories exist.
    """
    # Use sudo as we may not be a member of www-data.
    sudo("chmod -R 750 \"{0}\"".format(env.root_directory))
    sudo("chown -R {0}:www-data \"{1}\"".format(env.user, env.root_directory))

    # Make the static directory writable for django-compressor.
    sudo("chmod -R 770 \"{0}\"".format(os.path.join(
            env.project_directory, env.project_name, "static")))


# Calculate the host string and the path to the project directory.
env.hosts = [env.user + "@" + env.host]
env.project_directory = os.path.join(env.root_directory, env.project_name)

# Don't be so verbose.
ignore = ("running", "status", "stderr", "stdout", "warnings")
output.update(dict((level, False) for level in ignore))
